{"version":3,"file":"setup-playground-sync-08c3f510.js","sources":["../../../../../packages/php-wasm/fs-journal/src/lib/fs-journal.ts","../../../../../packages/playground/sync/src/sync-mu-plugin.php?raw","../../../../../packages/playground/sync/src/sql.ts","../../../../../packages/playground/sync/src/fs.ts","../../../../../packages/playground/sync/src/transports.ts","../../../../../packages/playground/sync/src/middleware/logger.ts","../../../../../packages/playground/sync/src/middleware/marshall-site-url.ts","../../../../../packages/playground/sync/src/middleware/prune-sql-queries.ts","../../../../../packages/playground/sync/src/middleware/hydrate-fs-writes.ts","../../../../../packages/playground/sync/src/setup-playground-sync.ts"],"sourcesContent":["import { PHP, UniversalPHP, __private__dont__use } from '@php-wasm/universal';\nimport { Semaphore, basename, joinPaths } from '@php-wasm/util';\nimport { logger } from '@php-wasm/logger';\n\nexport type EmscriptenFS = any;\n\n/**\n * Represents a stream in the Emscripten file system.\n */\nexport type EmscriptenFSStream = {\n\t/** The path of the node associated with this stream. */\n\tpath: string;\n\t/** The node associated with the stream. */\n\tnode: EmscriptenFSNode;\n};\n\n/**\n * Represents a node in the Emscripten file system.\n */\nexport type EmscriptenFSNode = {\n\t/**\n\t * The name of the file or directory.\n\t */\n\tname: string;\n\t/**\n\t * A binary flag encoding information about this note,\n\t * e.g. whether it's file or a directory.\n\t */\n\tmode: number;\n\t/**\n\t * A dictionary of functions representing operations\n\t * that can be performed on the node.\n\t */\n\tnode_ops: any;\n};\n\n/**\n * Represents the type of node in PHP file system.\n */\nexport type FSNodeType = 'file' | 'directory';\n\n/**\n * Represents an update operation on a file system node.\n */\nexport type UpdateFileOperation = {\n\t/** The type of operation being performed. */\n\toperation: 'WRITE';\n\t/** The path of the node being updated. */\n\tpath: string;\n\t/** Optional. The new contents of the file. */\n\tdata?: Uint8Array;\n\tnodeType: 'file';\n};\n\n/**\n * Represents a directory operation.\n */\nexport type CreateOperation = {\n\t/** The type of operation being performed. */\n\toperation: 'CREATE';\n\t/** The path of the node being created. */\n\tpath: string;\n\t/** The type of the node being created. */\n\tnodeType: FSNodeType;\n};\n\nexport type DeleteOperation = {\n\t/** The type of operation being performed. */\n\toperation: 'DELETE';\n\t/** The path of the node being updated. */\n\tpath: string;\n\t/** The type of the node being updated. */\n\tnodeType: FSNodeType;\n};\n\n/**\n * Represents a rename operation on a file or directory in PHP file system.\n */\nexport type RenameOperation = {\n\t/** The type of operation being performed. */\n\toperation: 'RENAME';\n\t/** The original path of the file or directory being renamed. */\n\tpath: string;\n\t/** The new path of the file or directory after the rename operation. */\n\ttoPath: string;\n\t/** The type of node being renamed (file or directory). */\n\tnodeType: FSNodeType;\n};\n\n/**\n * Represents a node in the file system.\n */\nexport type FSNode = {\n\t/** The name of this file or directory. */\n\tname: string;\n\t/** The type of this node (file or directory). */\n\ttype: FSNodeType;\n\t/** The contents of the file, if it is a file and it's stored in memory. */\n\tcontents?: string;\n\t/** The child nodes of the directory, if it is a directory. */\n\tchildren?: FSNode[];\n};\n\nexport type FilesystemOperation =\n\t| CreateOperation\n\t| UpdateFileOperation\n\t| DeleteOperation\n\t| RenameOperation;\n\nexport function journalFSEvents(\n\tphp: PHP,\n\tfsRoot: string,\n\tonEntry: (entry: FilesystemOperation) => void = () => {}\n) {\n\tfunction bindToCurrentRuntime() {\n\t\tfsRoot = normalizePath(fsRoot);\n\t\tconst FS = php[__private__dont__use].FS;\n\t\tconst FSHooks = createFSHooks(FS, (entry: FilesystemOperation) => {\n\t\t\t// Only journal entries inside the specified root directory.\n\t\t\tif (entry.path.startsWith(fsRoot)) {\n\t\t\t\tonEntry(entry);\n\t\t\t} else if (\n\t\t\t\tentry.operation === 'RENAME' &&\n\t\t\t\tentry.toPath.startsWith(fsRoot)\n\t\t\t) {\n\t\t\t\tfor (const op of recordExistingPath(\n\t\t\t\t\tphp,\n\t\t\t\t\tentry.path,\n\t\t\t\t\tentry.toPath\n\t\t\t\t)) {\n\t\t\t\t\tonEntry(op);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Override the original FS functions with ones running the hooks.\n\t\t * We could use a Proxy object here if the Emscripten JavaScript module\n\t\t * did not use hard-coded references to the FS object.\n\t\t */\n\t\tconst originalFunctions: Record<string, Function> = {};\n\t\tfor (const [name] of Object.entries(FSHooks)) {\n\t\t\toriginalFunctions[name] = FS[name];\n\t\t}\n\n\t\t// eslint-disable-next-line no-inner-declarations\n\t\tfunction bind() {\n\t\t\tfor (const [name, hook] of Object.entries(FSHooks)) {\n\t\t\t\tFS[name] = function (...args: any[]) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\thook(...args);\n\t\t\t\t\treturn originalFunctions[name].apply(this, args);\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\t// eslint-disable-next-line no-inner-declarations\n\t\tfunction unbind() {\n\t\t\t// Restore the original FS functions.\n\t\t\tfor (const [name, fn] of Object.entries(originalFunctions)) {\n\t\t\t\tphp[__private__dont__use].FS[name] = fn;\n\t\t\t}\n\t\t}\n\n\t\tphp[__private__dont__use].journal = {\n\t\t\tbind,\n\t\t\tunbind,\n\t\t};\n\t\tbind();\n\t}\n\tphp.addEventListener('runtime.initialized', bindToCurrentRuntime);\n\tif (php[__private__dont__use]) {\n\t\tbindToCurrentRuntime();\n\t}\n\n\tfunction unbindFromOldRuntime() {\n\t\tphp[__private__dont__use].journal.unbind();\n\t\tdelete php[__private__dont__use].journal;\n\t}\n\tphp.addEventListener('runtime.beforedestroy', unbindFromOldRuntime);\n\n\treturn function unbind() {\n\t\tphp.removeEventListener('runtime.initialized', bindToCurrentRuntime);\n\t\tphp.removeEventListener('runtime.beforedestroy', unbindFromOldRuntime);\n\t\treturn php[__private__dont__use].journal.unbind();\n\t};\n}\n\nconst createFSHooks = (\n\tFS: EmscriptenFS,\n\trecordEntry: (entry: FilesystemOperation) => void = () => {}\n) => ({\n\twrite(stream: EmscriptenFSStream) {\n\t\trecordEntry({\n\t\t\toperation: 'WRITE',\n\t\t\tpath: stream.path,\n\t\t\tnodeType: 'file',\n\t\t});\n\t},\n\ttruncate(path: string) {\n\t\tlet node;\n\t\tif (typeof path == 'string') {\n\t\t\tconst lookup = FS.lookupPath(path, {\n\t\t\t\tfollow: true,\n\t\t\t});\n\t\t\tnode = lookup.node;\n\t\t} else {\n\t\t\tnode = path;\n\t\t}\n\t\trecordEntry({\n\t\t\toperation: 'WRITE',\n\t\t\tpath: FS.getPath(node),\n\t\t\tnodeType: 'file',\n\t\t});\n\t},\n\tunlink(path: string) {\n\t\trecordEntry({\n\t\t\toperation: 'DELETE',\n\t\t\tpath,\n\t\t\tnodeType: 'file',\n\t\t});\n\t},\n\tmknod(path: string, mode: number) {\n\t\tif (FS.isFile(mode)) {\n\t\t\trecordEntry({\n\t\t\t\toperation: 'CREATE',\n\t\t\t\tpath,\n\t\t\t\tnodeType: 'file',\n\t\t\t});\n\t\t}\n\t},\n\tmkdir(path: string) {\n\t\trecordEntry({\n\t\t\toperation: 'CREATE',\n\t\t\tpath,\n\t\t\tnodeType: 'directory',\n\t\t});\n\t},\n\trmdir(path: string) {\n\t\trecordEntry({\n\t\t\toperation: 'DELETE',\n\t\t\tpath,\n\t\t\tnodeType: 'directory',\n\t\t});\n\t},\n\trename(old_path: string, new_path: string) {\n\t\ttry {\n\t\t\tconst oldLookup = FS.lookupPath(old_path, {\n\t\t\t\tfollow: true,\n\t\t\t});\n\t\t\tconst newParentPath = FS.lookupPath(new_path, {\n\t\t\t\tparent: true,\n\t\t\t}).path;\n\n\t\t\trecordEntry({\n\t\t\t\toperation: 'RENAME',\n\t\t\t\tnodeType: FS.isDir(oldLookup.node.mode) ? 'directory' : 'file',\n\t\t\t\tpath: oldLookup.path,\n\t\t\t\ttoPath: joinPaths(newParentPath, basename(new_path)),\n\t\t\t});\n\t\t} catch (e) {\n\t\t\t// We're running a bunch of FS lookups that may fail at this point.\n\t\t\t// Let's ignore the failures and let the actual rename operation\n\t\t\t// fail if it needs to.\n\t\t}\n\t},\n});\n\n/**\n * Replays a list of filesystem operations on a PHP instance.\n *\n * @param php\n * @param entries\n */\nexport function replayFSJournal(php: PHP, entries: FilesystemOperation[]) {\n\t// We need to restore the original functions to the FS object\n\t// before proceeding, or each replayed FS operation will be journaled.\n\t//\n\t// Unfortunately we can't just call the non-journaling versions directly,\n\t// because they call other low-level FS functions like `FS.mkdir()`\n\t// and will trigger the journaling hooks anyway.\n\tphp[__private__dont__use].journal.unbind();\n\ttry {\n\t\tfor (const entry of entries) {\n\t\t\tif (entry.operation === 'CREATE') {\n\t\t\t\tif (entry.nodeType === 'file') {\n\t\t\t\t\tphp.writeFile(entry.path, ' ');\n\t\t\t\t} else {\n\t\t\t\t\tphp.mkdir(entry.path);\n\t\t\t\t}\n\t\t\t} else if (entry.operation === 'DELETE') {\n\t\t\t\tif (entry.nodeType === 'file') {\n\t\t\t\t\tphp.unlink(entry.path);\n\t\t\t\t} else {\n\t\t\t\t\tphp.rmdir(entry.path);\n\t\t\t\t}\n\t\t\t} else if (entry.operation === 'WRITE') {\n\t\t\t\tphp.writeFile(entry.path, entry.data!);\n\t\t\t} else if (entry.operation === 'RENAME') {\n\t\t\t\tphp.mv(entry.path, entry.toPath);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tphp[__private__dont__use].journal.bind();\n\t}\n}\n\nexport function* recordExistingPath(\n\tphp: PHP,\n\tfromPath: string,\n\ttoPath: string\n): Generator<FilesystemOperation> {\n\tif (php.isDir(fromPath)) {\n\t\t// The rename operation moved a directory from outside root directory\n\t\t// into the root directory. We need to traverse the entire tree\n\t\t// and provide a create operation for each file and directory.\n\t\tyield {\n\t\t\toperation: 'CREATE',\n\t\t\tpath: toPath,\n\t\t\tnodeType: 'directory',\n\t\t};\n\t\tfor (const file of php.listFiles(fromPath)) {\n\t\t\tyield* recordExistingPath(\n\t\t\t\tphp,\n\t\t\t\tjoinPaths(fromPath, file),\n\t\t\t\tjoinPaths(toPath, file)\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// The rename operation moved a file from outside root directory\n\t\t// into the root directory. Let's rewrite it as a create operation.\n\t\tyield {\n\t\t\toperation: 'CREATE',\n\t\t\tpath: toPath,\n\t\t\tnodeType: 'file',\n\t\t};\n\t\tyield {\n\t\t\toperation: 'WRITE',\n\t\t\tnodeType: 'file',\n\t\t\tpath: toPath,\n\t\t};\n\t}\n}\n\nfunction normalizePath(path: string) {\n\treturn path.replace(/\\/$/, '').replace(/\\/\\/+/g, '/');\n}\n\n/**\n * Normalizes a list of filesystem operations to remove\n * redundant operations.\n *\n * This is crucial because the journal doesn't store the file contents\n * on write, but only the information that the write happened. We only\n * read the contents of the file on flush. However, at that time the file\n * could have been moved to another location so we need this function to\n * rewrite the journal to reflect the current file location. Only then\n * will the hydrateUpdateFileOps() function be able to do its job.\n *\n * @param journal The original journal.\n * @returns The normalized journal.\n */\nexport function normalizeFilesystemOperations(\n\tjournal: FilesystemOperation[]\n): FilesystemOperation[] {\n\tconst substitutions: Record<number, any> = {};\n\tfor (let i = journal.length - 1; i >= 0; i--) {\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst formerType = checkRelationship(journal[i], journal[j]);\n\t\t\tif (formerType === 'none') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst latter = journal[i];\n\t\t\tconst former = journal[j];\n\t\t\tif (\n\t\t\t\tlatter.operation === 'RENAME' &&\n\t\t\t\tformer.operation === 'RENAME'\n\t\t\t) {\n\t\t\t\t// Normalizing a double rename is a complex scenario so let's just give\n\t\t\t\t// up. There's just too many possible scenarios to handle.\n\t\t\t\t//\n\t\t\t\t// For example, the following scenario may not be possible to normalize:\n\t\t\t\t// RENAME /dir_a /dir_b\n\t\t\t\t// RENAME /dir_b/subdir /dir_c\n\t\t\t\t// RENAME /dir_b /dir_d\n\t\t\t\t//\n\t\t\t\t// Similarly, how should we normalize the following list?\n\t\t\t\t// CREATE_FILE /file\n\t\t\t\t// CREATE_DIR /dir_a\n\t\t\t\t// RENAME /file /dir_a/file\n\t\t\t\t// RENAME /dir_a /dir_b\n\t\t\t\t// RENAME /dir_b/file /dir_b/file_2\n\t\t\t\t//\n\t\t\t\t// The shortest way to recreate the same structure would be this:\n\t\t\t\t// CREATE_DIR /dir_b\n\t\t\t\t// CREATE_FILE /dir_b/file_2\n\t\t\t\t//\n\t\t\t\t// But that's not a straightforward transformation so let's just not\n\t\t\t\t// handle it for now.\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'[FS Journal] Normalizing a double rename is not yet supported:',\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrent: latter,\n\t\t\t\t\t\tlast: former,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (former.operation === 'CREATE' || former.operation === 'WRITE') {\n\t\t\t\tif (latter.operation === 'RENAME') {\n\t\t\t\t\tif (formerType === 'same_node') {\n\t\t\t\t\t\t// Creating a node and then renaming it is equivalent to creating\n\t\t\t\t\t\t// it in the new location.\n\t\t\t\t\t\tsubstitutions[j] = [];\n\t\t\t\t\t\tsubstitutions[i] = [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t...former,\n\t\t\t\t\t\t\t\tpath: latter.toPath,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t...(substitutions[i] || []),\n\t\t\t\t\t\t];\n\t\t\t\t\t} else if (formerType === 'descendant') {\n\t\t\t\t\t\t// Creating a node and then renaming its parent directory is\n\t\t\t\t\t\t// equivalent to creating it in the new location.\n\t\t\t\t\t\tsubstitutions[j] = [];\n\t\t\t\t\t\tsubstitutions[i] = [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t...former,\n\t\t\t\t\t\t\t\tpath: joinPaths(\n\t\t\t\t\t\t\t\t\tlatter.toPath,\n\t\t\t\t\t\t\t\t\tformer.path.substring(latter.path.length)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t...(substitutions[i] || []),\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t} else if (\n\t\t\t\t\tlatter.operation === 'WRITE' &&\n\t\t\t\t\tformerType === 'same_node'\n\t\t\t\t) {\n\t\t\t\t\t// Updating the same node twice is equivalent to updating it once\n\t\t\t\t\t// at the later time.\n\t\t\t\t\tsubstitutions[j] = [];\n\t\t\t\t} else if (\n\t\t\t\t\tlatter.operation === 'DELETE' &&\n\t\t\t\t\tformerType === 'same_node'\n\t\t\t\t) {\n\t\t\t\t\t// Creating a node and then deleting it is equivalent to doing\n\t\t\t\t\t// nothing.\n\t\t\t\t\tsubstitutions[j] = [];\n\t\t\t\t\tsubstitutions[i] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Any substiturions? Apply them and and start over.\n\t\t// We can't just continue as the current operation may\n\t\t// have been replaced.\n\t\tif (Object.entries(substitutions).length > 0) {\n\t\t\tconst updated = journal.flatMap((op, index) => {\n\t\t\t\tif (!(index in substitutions)) {\n\t\t\t\t\treturn [op];\n\t\t\t\t}\n\t\t\t\treturn substitutions[index];\n\t\t\t});\n\t\t\treturn normalizeFilesystemOperations(updated);\n\t\t}\n\t}\n\treturn journal;\n}\n\ntype RelatedOperationInfo = 'same_node' | 'ancestor' | 'descendant' | 'none';\nfunction checkRelationship(\n\tlatter: FilesystemOperation,\n\tformer: FilesystemOperation\n): RelatedOperationInfo {\n\tconst latterPath = latter.path;\n\tconst latterIsDir =\n\t\tlatter.operation !== 'WRITE' && latter.nodeType === 'directory';\n\tconst formerIsDir =\n\t\tformer.operation !== 'WRITE' && former.nodeType === 'directory';\n\tconst formerPath =\n\t\tformer.operation === 'RENAME' ? former.toPath : former.path;\n\n\tif (formerPath === latterPath) {\n\t\treturn 'same_node';\n\t} else if (formerIsDir && latterPath.startsWith(formerPath + '/')) {\n\t\treturn 'ancestor';\n\t} else if (latterIsDir && formerPath.startsWith(latterPath + '/')) {\n\t\treturn 'descendant';\n\t}\n\treturn 'none';\n}\n\n/**\n * Populates each WRITE operation with the contents of\n * said file.\n *\n * Mutates the original array.\n *\n * @param php\n * @param entries\n */\nexport async function hydrateUpdateFileOps(\n\tphp: UniversalPHP,\n\tentries: FilesystemOperation[]\n) {\n\tconst updateFileOps = entries.filter(\n\t\t(op): op is UpdateFileOperation => op.operation === 'WRITE'\n\t);\n\tconst updates = updateFileOps.map((op) => hydrateOp(php, op));\n\tawait Promise.all(updates);\n\treturn entries;\n}\n\nconst hydrateLock = new Semaphore({ concurrency: 15 });\nasync function hydrateOp(php: UniversalPHP, op: UpdateFileOperation) {\n\tconst release = await hydrateLock.acquire();\n\n\t// There is a race condition here:\n\t// The file could have been removed from the filesystem\n\t// between the flush() call and now. If that happens, we won't\n\t// be able to read it here.\n\t//\n\t// If the file was DELETEd, we're fine as the next flush() will\n\t// propagate the DELETE operation.\n\t//\n\t// If the file was RENAMEd, we're in trouble as we're about to\n\t// tell the other peer to create an empty file and the next\n\t// flush() will rename that empty file.\n\t//\n\t// This issue requires a particular timing and is unlikely to ever happen,\n\t// but is definitely possible. We could mitigate it by either:\n\t//\n\t// * Peeking into the buffered journal entries since the last flush() to\n\t//   source the file path from\n\t// * Storing the data at the journaling stage instead of the flush() stage,\n\t//   (and using potentially a lot of additional memory to keep track of all\n\t//    the intermediate stages)\n\t//\n\t// For now, htough, let's just add error logging and keep an eye on this\n\t// to see if this actually ever happens.\n\ttry {\n\t\top.data = await php.readFileAsBuffer(op.path);\n\t} catch (e) {\n\t\t// Log the error but don't throw.\n\t\tlogger.warn(\n\t\t\t`Journal failed to hydrate a file on flush: the ` +\n\t\t\t\t`path ${op.path} no longer exists`\n\t\t);\n\t\tlogger.error(e);\n\t}\n\n\trelease();\n}\n","export default \"<?php\\n\\n/**\\n * Forces SQLite to use monotonically increasing values for every \\n * autoincrement column. For example, if sqlite_sequence says that\\n * `wp_posts` has seq=10, the next row will get id=11.\\n * \\n * ## How to use\\n * \\n * * Call this function when starting the synchronized session.\\n * * Call this function again every time a new autoincrement field is created.\\n * \\n * ## Doesn't SQLite already do that?\\n * \\n * Sadly, no.\\n * \\n * SQLite always uses max(id) + 1 for the next autoincrement value\\n * regardless of the seq value stored in sqlite_sequence.\\n * \\n * This means trouble. Receiving a remote row with a high ID like 450000 \\n * changes the next locally assigned ID from 11 to 450001. This is a \\n * certain way to get ID conflicts between peers.\\n * \\n * Fortunately, we can create a trigger to force SQLite to use ID=seq+1\\n * instead of its default algorithm.\\n * \\n * ## Implementation\\n *\\n * We override the default AUTOINCREMENT algorithm with our own.\\n * \\n * Instead of sqlite_sequence, we use a custom playground_sequence table\\n * to store the next available ID for every table/column pair.\\n * \\n * We use an AFTER INSERT trigger to reassign the AUTOINCREMENT value to the\\n * next available value in the playground_sequence table.\\n * \\n * The last_insert_id() function still returns the original ID assigned by SQLite,\\n * so we introduce a new 'sqlite_last_insert_id' filter in class-wp-sqlite-translator.php\\n * and use it to give WordPress the correct last_insert_id.\\n * \\n * ## Alternatives considered\\n * \\n * * Using a custom DEFAULT value for the PRIMARY KEY column – SQLite doesn't support it\\n * * Update ID with a trigger BEFORE INSERT – SQLite doesn't support it\\n * * Use INSTEAD OF triggers on a table – they only work with views\\n * * Read the entire row after INSERTing it, and reconstruct the query – too complex and be error-prone\\n * * Replace the ID column with a custom, non-autoincrement one – that's complex in SQLite plus it could mess up WP core db migrations\\n * \\n * @param int|null $local_id_offset The offset to use for the first AUTOINCREMENT value.\\n * @return void\\n */\\nfunction playground_sync_override_autoincrement_algorithm($local_id_offset = null, $known_autoincrement_values = null)\\n{\\n    if (null !== $local_id_offset) {\\n        if (get_option('playground_id_offset')) {\\n            // For now, the initial offset may only be set once.\\n            // Changing it on the fly has no clear benefits, but\\n            // it would be a pain to implement correctly and would\\n            // introduce inconvenient gaps in the ID sequence.\\n            throw new Exception(\\n                \\\"playground_sync_override_autoincrement_algorithm() was called twice with different \\\" .\\n                \\\"values for \\\\$local_id_offset. This is not supported.\\\"\\n            );\\n        }\\n        // Store the default autoincrement offset for the current peer:\\n        update_option('playground_id_offset', $local_id_offset);\\n    }\\n\\n    if (null !== $known_autoincrement_values) {\\n        foreach ($known_autoincrement_values as $table_name => $seq) {\\n            $stmt = $GLOBALS['@pdo']->prepare(<<<SQL\\n                INSERT OR REPLACE INTO playground_sequence VALUES (:table_name, :seq)\\n            SQL\\n            );\\n            $stmt->execute([':table_name' => $table_name, ':seq' => $seq]);\\n        }\\n    }\\n\\n    // Insert all the AUTOINCREMENT table/column pairs that are not\\n    // already tracked in playground_sequence:\\n    $pdo = $GLOBALS['@pdo'];\\n    $stmt = $pdo->prepare(<<<SQL\\n        INSERT INTO playground_sequence \\n        SELECT table_name, :seq FROM autoincrement_columns\\n        WHERE 1=1 -- Needed because of the ambiguous ON clause, see https://sqlite.org/lang_upsert.html\\n        ON CONFLICT(table_name) DO NOTHING;\\n    SQL);\\n    $stmt->execute([':seq' => get_option('playground_id_offset')]);\\n\\n    // Create any missing AFTER INSERT triggers:\\n    foreach (playground_sync_get_autoincrement_columns() as $table => $column) {\\n        $pdo->query(<<<SQL\\n            CREATE TRIGGER IF NOT EXISTS \\n            force_seq_autoincrement_on_{$table}_{$column}\\n            AFTER INSERT ON $table\\n            FOR EACH ROW\\n            WHEN\\n                -- Don't run this trigger when we're replaying queries from another peer\\n                (SELECT value FROM playground_variables WHERE name = 'is_replaying') = 'no'\\n            BEGIN\\n                -- Update the inserted row with the next available ID\\n                UPDATE {$table} SET {$column} = (\\n                    SELECT seq FROM playground_sequence WHERE table_name = '{$table}'\\n                ) + 1 WHERE rowid = NEW.rowid;\\n                -- Record the ID that was just assigned\\n                UPDATE playground_sequence SET seq = seq + 1 WHERE table_name = '{$table}';\\n            END;\\n        SQL);\\n    }\\n}\\n\\n/**\\n * Same as playground_sync_override_autoincrement_algorithm(), only runs after\\n * queries that modify the database schema, such as ALTER TABLE and CREATE TABLE.\\n * \\n * @param string $query MySQL Query\\n * @param string $query_type CREATE TABLE, ALTER TABLE, etc.\\n * @return void\\n */\\nfunction playground_sync_override_autoincrement_on_newly_created_fields($query, $query_type)\\n{\\n    if ($query_type === 'CREATE TABLE' || $query_type === 'ALTER TABLE') {\\n        playground_sync_override_autoincrement_algorithm();\\n    }\\n}\\n\\n/**\\n * Ensures that $wpdb gets the actual ID assigned to the last inserted row\\n * as its $wpdb->insert_id value.\\n * \\n * The AFTER INSERT trigger overrides AUTOINCREMENT IDs provided by SQLite.\\n * However, the SQLite integration plugin uses the builtin last_insert_id() \\n * SQLite function which returns the original ID assigned by SQLite. That ID\\n * is no longer in the database, but there is no way to override it at the\\n * database level.\\n * \\n * We must, therefore, act at the application level. This function replaces\\n * the stale ID with the one assigned to the row by the AFTER INSERT trigger.\\n * \\n * @see playground_autoincrement_override_algorithm\\n * \\n * @param int $sqlite_last_insert_id The now-stale ID returned by last_insert_id().\\n * @param string $table_name The table name.\\n * @return int The ID actually stored in the last inserted row.\\n */\\nfunction playground_sync_get_actual_last_insert_id($sqlite_last_insert_id, $table_name)\\n{\\n    // Get the last relevant value from playground_sequence:\\n    $stmt = $GLOBALS['@pdo']->prepare(\\\"SELECT * FROM playground_sequence WHERE table_name = :table_name\\\");\\n    $stmt->execute([':table_name' => $table_name]);\\n    $result = $stmt->fetch(PDO::FETCH_ASSOC);\\n    if ($result) {\\n        return $result['seq'];\\n    }\\n    return $sqlite_last_insert_id;\\n}\\n/**\\n * Returns all auto-increment columns keyed by their table name.\\n *\\n * @return array A [$table => $column] array of all auto-increment columns.\\n */\\nfunction playground_sync_get_autoincrement_columns()\\n{\\n    return $GLOBALS['@pdo']\\n        ->query('SELECT table_name, column_name FROM autoincrement_columns')\\n        ->fetchAll(PDO::FETCH_KEY_PAIR);\\n}\\n\\n/**\\n * Ensures that all the tables and views required by the synchronization\\n * process exist.\\n *\\n * This function may be called multiple times without causing an error.\\n * \\n * @return void\\n */\\nfunction playground_sync_ensure_required_tables()\\n{\\n    $pdo = $GLOBALS['@pdo'];\\n    /** @var PDO $pdo */\\n    $pdo->query(\\\"CREATE TABLE IF NOT EXISTS playground_variables (\\n        name TEXT PRIMARY KEY,\\n        value TEXT\\n    );\\\");\\n    $pdo->query(\\\"CREATE TABLE IF NOT EXISTS playground_sequence (\\n        table_name varchar(255),\\n        seq int default 0 not null,\\n        PRIMARY KEY (table_name)\\n    )\\\");\\n\\n    $pdo->query(<<<SQL\\n    CREATE VIEW IF NOT EXISTS autoincrement_columns AS \\n        SELECT DISTINCT m.name as 'table_name', ti.name AS 'column_name'\\n            FROM\\n                sqlite_schema AS m,\\n                pragma_table_info(m.name) AS ti\\n            INNER JOIN sqlite_sequence seq ON seq.name = m.name\\n            WHERE\\n                m.type = 'table' AND\\n                m.name NOT LIKE 'sqlite_%' AND\\n                ti.pk = 1 AND -- pk stands for primary key\\n                ti.type LIKE '%INTEGER%'\\n            ORDER BY 1\\n    ;\\n    SQL\\n    );\\n}\\n\\n/**\\n * Emits a SQL query to the JavaScript side of the Playground Sync\\n * feature.\\n *\\n * If the query is an INSERT and the local database implicitly assigned\\n * a primary key, this function will send the inserted rows instead of\\n * the original query. We do this because the original query doesn't\\n * give the remote peer enough information to reconstruct the row.\\n *\\n * @param string $query The SQL query to emit.\\n * @param string $query_type The type of the SQL query (e.g. SELECT, INSERT, UPDATE, DELETE).\\n * @param string $table_name The name of the table affected by the SQL query.\\n * @param array $insert_columns The columns affected by the INSERT query.\\n * @param int $last_insert_id The ID of the last inserted row (if applicable).\\n * @param int $affected_rows The number of affected rows.\\n * @return void\\n */\\nfunction playground_sync_emit_mysql_query($query, $query_type, $table_name, $insert_columns, $last_insert_id, $affected_rows)\\n{\\n    // Is it an INSERT that generated a new autoincrement value?\\n    static $auto_increment_columns = null;\\n    if ($auto_increment_columns === null) {\\n        $auto_increment_columns = playground_sync_get_autoincrement_columns();\\n    }\\n    $auto_increment_column = $auto_increment_columns[$table_name] ?? null;\\n\\n    $was_pk_generated = $query_type === 'INSERT' && $auto_increment_column && !in_array($auto_increment_column, $insert_columns, true);\\n    if ($was_pk_generated) {\\n        // If so, get the inserted rows.\\n        // It could be more than one, e.g. if the query was `INSERT INTO ... SELECT ...`.\\n        $rows = $GLOBALS['@pdo']->query(<<<SQL\\n            SELECT * FROM $table_name\\n            WHERE $auto_increment_column <= $last_insert_id\\n            ORDER BY $auto_increment_column DESC\\n            LIMIT $affected_rows\\n        SQL\\n        )->fetchAll(PDO::FETCH_ASSOC);\\n        // Finally, send each row to the JavaScript side.\\n        foreach ($rows as $row) {\\n            $row[$auto_increment_column] = (int) $row[$auto_increment_column];\\n            post_message_to_js(json_encode([\\n                'type' => 'sql',\\n                'subtype' => 'reconstruct-insert',\\n                'row' => $row,\\n                'query_type' => $query_type,\\n                'table_name' => $table_name,\\n                'auto_increment_column' => $auto_increment_column,\\n                'last_insert_id' => $last_insert_id,\\n            ]));\\n        }\\n        return;\\n    }\\n\\n    // Otherwise, simply send the query to the JavaScript side.\\n    post_message_to_js(json_encode([\\n        'type' => 'sql',\\n        'subtype' => 'replay-query',\\n        'query' => $query,\\n        'query_type' => $query_type,\\n        'table_name' => $table_name,\\n        'auto_increment_column' => $auto_increment_column,\\n        'last_insert_id' => $last_insert_id,\\n    ]));\\n}\\n\\n/**\\n * Emits a transaction-related query to the JavaScript side of the \\n * Playground Sync.\\n *\\n * @param string $command The SQL statement (one of \\\"START TRANSACTION\\\", \\\"COMMIT\\\", \\\"ROLLBACK\\\").\\n * @param bool $success Whether the SQL statement was successful or not.\\n * @param int $nesting_level The nesting level of the transaction.\\n * @return void\\n */\\nfunction playground_sync_emit_transaction_query($command, $success, $nesting_level)\\n{\\n    // If we're in a nested transaction, SQLite won't really\\n    // persist anything to the database. Let's ignore it and wait\\n    // for the outermost transaction to finish.\\n    if (0 !== $nesting_level) {\\n        return;\\n    }\\n\\n    post_message_to_js(json_encode([\\n        'type' => 'sql',\\n        'subtype' => 'transaction',\\n        'success' => $success,\\n        'command' => $command,\\n    ]));\\n}\\n\\n/**\\n * Replays a list of SQL queries on a local database.\\n * \\n * @param array $queries An array of SQL queries to run.\\n * @return void\\n */\\nfunction playground_sync_replay_sql_journal($queries)\\n{\\n    global $wpdb;\\n    $pdo = $GLOBALS['@pdo'];\\n    foreach ($queries as $query) {\\n        try {\\n            // If another peer assigned an autoincrement value, we don't get\\n            // the query but a key/value representation of the inserted row.\\n            // Let's reconstruct the INSERT query using that data.\\n            // Because we use prepared statements here, we cannot simply reconstruct the\\n            // insert on the other end.\\n            if ($query['subtype'] === 'reconstruct-insert') {\\n                $table_name = $query['table_name'];\\n                $columns = implode(', ', array_keys($query['row']));\\n                $placeholders = ':' . implode(', :', array_keys($query['row']));\\n\\n                $stmt = $pdo->prepare(\\\"INSERT INTO $table_name ($columns) VALUES ($placeholders)\\\");\\n                $stmt->execute($query['row']);\\n            } else {\\n                $wpdb->query($query['query']);\\n            }\\n        } catch (PDOException $e) {\\n            // Let's ignore errors related to UNIQUE constraints violation for now.\\n            // They often relate to transient data that is not relevant to the\\n            // synchronization process.\\n            //\\n            // This probably means we won't catch some legitimate issues.\\n            // Let's keep an eye on this and see if we can eventually remove it.\\n            // In the future, let's implement pattern matching on queries and\\n            // prevent synchronizing transient data. \\n\\n            // SQLSTATE[23000]: Integrity constraint violation: 19 UNIQUE constraint failed\\n            if ($e->getCode() === \\\"23000\\\") {\\n                continue;\\n            }\\n            throw $e;\\n        }\\n    }\\n}\\n\\n/**\\n * Sets up WordPress for a synchronized exchange of SQLite queries.\\n * \\n * @return void\\n */\\nfunction playground_sync_start()\\n{\\n    playground_sync_ensure_required_tables();\\n\\n    // Don't override the AUTOINCREMENT IDs when replaying queries from \\n    // another peer. The AFTER INSERT trigger will abstain from running\\n    // when `is_replaying` is set to \\\"yes\\\".\\n    $pdo = $GLOBALS['@pdo'];\\n    $stmt = $pdo->prepare(\\\"INSERT OR REPLACE INTO playground_variables VALUES ('is_replaying', :is_replaying);\\\");\\n    $is_replaying = defined('REPLAYING_SQL') && REPLAYING_SQL;\\n    $stmt->execute([':is_replaying' => $is_replaying ? 'yes' : 'no']);\\n\\n    // Don't emit SQL queries we're just replaying from another peer.\\n    if (!$is_replaying) {\\n        add_filter('sqlite_last_insert_id', 'playground_sync_get_actual_last_insert_id', 0, 2);\\n\\n        // Listens for SQL queries executed by WordPress and emit them to the JS side:\\n        // @todo – consider using SQLite's \\\"update hook\\\" instead of \\\"sqlite_post_query\\\" WordPress hook here.\\n        add_action('sqlite_translated_query_executed', 'playground_sync_emit_mysql_query', -1000, 6);\\n        add_action('sqlite_transaction_query_executed', 'playground_sync_emit_transaction_query', -1000, 3);\\n    }\\n\\n    add_filter('sqlite_translated_query_executed', 'playground_sync_override_autoincrement_on_newly_created_fields', -1000, 2);\\n}\\n\\nplayground_sync_start();\"","import { PHPResponse, UniversalPHP } from '@php-wasm/universal';\nimport { logger } from '@php-wasm/logger';\n/** @ts-ignore */\nimport logSqlQueries from './sync-mu-plugin.php?raw';\nimport { phpVar, phpVars } from '@php-wasm/util';\n\nexport async function installSqlSyncMuPlugin(playground: UniversalPHP) {\n\tif (!(await playground.fileExists('/wordpress/wp-content/mu-plugins'))) {\n\t\tawait playground.mkdir('/wordpress/wp-content/mu-plugins');\n\t}\n\tawait playground.writeFile(\n\t\t`/wordpress/wp-content/mu-plugins/sync-mu-plugin.php`,\n\t\tlogSqlQueries\n\t);\n}\n\nexport async function overrideAutoincrementSequences(\n\tplayground: UniversalPHP,\n\tbaseOffset: number,\n\tknownIds: Record<string, number> = {}\n) {\n\tconst initializationResult = await playground.run({\n\t\tcode: `<?php\n        require '/wordpress/wp-load.php';\n        playground_sync_override_autoincrement_algorithm(\n\t\t\t${phpVar(baseOffset)},\n\t\t\t${phpVar(knownIds)}\n\t\t);\n\t    `,\n\t});\n\tassertEmptyOutput(initializationResult, 'Initialization failed.');\n\n\t// Get the current autoincrement ID value for all tables\n\tconst response = await playground.run({\n\t\tcode: `<?php\n        require '/wordpress/wp-load.php';\n\t\t$data = $GLOBALS['@pdo']\n\t\t\t->query('SELECT * FROM playground_sequence')\n\t\t\t->fetchAll(PDO::FETCH_KEY_PAIR);\n\t\techo json_encode($data);\n\t\t`,\n\t});\n\treturn response.json;\n}\n\n/**\n * Listens to SQL queries and transactions on a PlaygroundClient instance,\n * and records them in a journal. When a transaction is committed, the\n * provided callback is called for every query in the transaction.\n *\n * @param playground The PlaygroundClient instance to listen to.\n * @param onCommit The callback to invoke when a transaction is committed.\n */\nexport async function journalSQLQueries(\n\tplayground: UniversalPHP,\n\tonCommit: (queries: SQLJournalEntry) => void\n) {\n\tlet activeTransaction: SQLJournalEntry[] | null = null;\n\n\t// When PHP request terminates, any uncommitted\n\t// queries in the active transaction are rolled back.\n\tplayground.addEventListener('request.end', () => {\n\t\tactiveTransaction = null;\n\t});\n\tplayground.onMessage(async (messageString: string) => {\n\t\tconst message = JSON.parse(messageString) as any;\n\t\tif (message?.type !== 'sql') {\n\t\t\treturn;\n\t\t}\n\t\tif (message.subtype === 'transaction') {\n\t\t\tconst command = message as SQLTransactionCommand;\n\t\t\tif (!command.success) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch (command.command) {\n\t\t\t\tcase 'START TRANSACTION':\n\t\t\t\t\tactiveTransaction = [];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'COMMIT':\n\t\t\t\t\tif (activeTransaction?.length) {\n\t\t\t\t\t\tactiveTransaction.forEach(onCommit);\n\t\t\t\t\t}\n\t\t\t\t\tactiveTransaction = null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ROLLBACK':\n\t\t\t\t\tactiveTransaction = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tmessage.subtype === 'replay-query' ||\n\t\t\tmessage.subtype === 'reconstruct-insert'\n\t\t) {\n\t\t\tconst entry = message as SQLJournalEntry;\n\t\t\tif (activeTransaction) {\n\t\t\t\tactiveTransaction.push(entry);\n\t\t\t} else {\n\t\t\t\tonCommit(entry);\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport async function replaySQLJournal(\n\tplayground: UniversalPHP,\n\tjournal: SQLJournalEntry[]\n) {\n\tconst js = phpVars({ journal });\n\tconst result = await playground.run({\n\t\tcode: `<?php\n\t\t// Prevent reporting changes from queries we're just replaying\n\t\tdefine('REPLAYING_SQL', true);\n\n\t\t// Only load WordPress and replay the SQL queries now\n\t\trequire '/wordpress/wp-load.php';\n\t\tplayground_sync_replay_sql_journal(${js.journal});\n\t`,\n\t});\n\tassertEmptyOutput(result, 'Replay error.');\n}\n\nfunction assertEmptyOutput(result: PHPResponse, errorMessage: string) {\n\tif (result.text.trim() || result.errors.trim()) {\n\t\tlogger.error({\n\t\t\ttext: result.text,\n\t\t\terrors: result.errors,\n\t\t});\n\t\tthrow new Error(`${errorMessage}. See the console for more details.`);\n\t}\n}\n\nexport type ReplayQuery = {\n\ttype: 'sql';\n\tsubtype: 'replay-query';\n\tquery: string;\n\tquery_type: string;\n\ttable_name: string;\n\tauto_increment_column: string;\n\tlast_insert_id: number;\n};\n\nexport type ReconstructInsert = {\n\ttype: 'sql';\n\tsubtype: 'reconstruct-insert';\n\tquery_type: 'INSERT';\n\trow: Record<string, string | number | null>;\n\ttable_name: string;\n\tauto_increment_column: string;\n\tlast_insert_id: number;\n};\n\nexport type SQLJournalEntry = ReplayQuery | ReconstructInsert;\n\nexport type SQLTransactionCommand =\n\t| {\n\t\t\ttype: 'sql';\n\t\t\tsubtype: 'transaction';\n\t\t\tcommand: 'START TRANSACTION';\n\t\t\tsuccess: boolean;\n\t  }\n\t| {\n\t\t\ttype: 'sql';\n\t\t\tsubtype: 'transaction';\n\t\t\tcommand: 'COMMIT';\n\t\t\tsuccess: boolean;\n\t  }\n\t| {\n\t\t\ttype: 'sql';\n\t\t\tsubtype: 'transaction';\n\t\t\tcommand: 'ROLLBACK';\n\t\t\tsuccess: boolean;\n\t  };\n","import { FilesystemOperation } from '@php-wasm/fs-journal';\nimport { PlaygroundClient } from '@wp-playground/client';\n\nexport async function journalFSOperations(\n\tplayground: PlaygroundClient,\n\tonEntry: (op: FilesystemOperation) => void\n) {\n\tawait playground.journalFSEvents(\n\t\t'/wordpress/wp-content',\n\t\tasync (entry: FilesystemOperation) => {\n\t\t\tif (\n\t\t\t\tentry.path.endsWith('/.ht.sqlite') ||\n\t\t\t\tentry.path.endsWith('/.ht.sqlite-journal')\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tonEntry(entry);\n\t\t}\n\t);\n}\n","import { FilesystemOperation } from '@php-wasm/fs-journal';\nimport { SQLJournalEntry } from './sql';\n\nexport type TransportEnvelope = {\n\tfs: FilesystemOperation[];\n\tsql: SQLJournalEntry[];\n};\n\nexport type ChangesCallback = (changes: TransportEnvelope) => void;\nexport interface PlaygroundSyncTransport {\n\tsendChanges(data: TransportEnvelope): void;\n\tonChangesReceived(fn: ChangesCallback): void;\n}\n\nexport class ParentWindowTransport implements PlaygroundSyncTransport {\n\tsendChanges(envelope: TransportEnvelope) {\n\t\twindow.top!.postMessage(\n\t\t\t{\n\t\t\t\ttype: 'playground-change',\n\t\t\t\tenvelope,\n\t\t\t},\n\t\t\t'*'\n\t\t);\n\t}\n\n\tonChangesReceived(fn: ChangesCallback): void {\n\t\twindow.addEventListener('message', (event) => {\n\t\t\tif (event.data.type !== 'playground-change') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfn(event.data.envelope);\n\t\t});\n\t}\n}\n\nexport class NoopTransport implements PlaygroundSyncTransport {\n\tsendChanges() {}\n\tonChangesReceived(callback: ChangesCallback) {\n\t\tthis.injectChanges = callback;\n\t}\n\tinjectChanges(changes: TransportEnvelope) {}\n}\n","import { SyncMiddleware } from '.';\nimport { logger } from '@php-wasm/logger';\n\nexport function loggerMiddleware(clientId: string): SyncMiddleware {\n\treturn {\n\t\tbeforeSend: (envelope) => {\n\t\t\tif (envelope.sql.length > 0 || envelope.fs.length > 0) {\n\t\t\t\tlogger.log(`[${clientId}] Sending changes`, envelope);\n\t\t\t}\n\t\t\treturn envelope;\n\t\t},\n\t\tafterReceive: (envelope) => {\n\t\t\tlogger.log(`[${clientId}] Received changes`, envelope);\n\t\t\treturn envelope;\n\t\t},\n\t};\n}\n","import { TransportEnvelope } from '../transports';\n\nexport const marshallSiteURLMiddleware = (\n\tlocalSiteUrl: string,\n\tplaceholderUrl = 'https://playground.wordpress.net'\n) => {\n\treturn {\n\t\tbeforeSend: siteURLMapper(localSiteUrl, placeholderUrl),\n\t\tafterReceive: siteURLMapper(placeholderUrl, localSiteUrl),\n\t};\n};\n\n/**\n * Maps the WordPress site URL from one value to another in SQL\n * query journal.\n *\n * @param fromURL - The original site URL to be replaced.\n * @param toURL - The new site URL to replace the original.\n * @returns Mapper function.\n */\nfunction siteURLMapper(fromURL: string, toURL: string) {\n\t// Remove trailing slashes for consistency\n\tfromURL = fromURL.replace(/\\/$/, '');\n\ttoURL = toURL.replace(/\\/$/, '');\n\n\tconst urlRegexp = new RegExp(\n\t\t`(^|[^0-9a-zA-Z])(?:${escapeRegex(fromURL)})($|[^0-9a-zA-Z])`,\n\t\t'g'\n\t);\n\tconst urlReplacement = `$1${toURL}$2`;\n\n\treturn (envelope: TransportEnvelope) => ({\n\t\t...envelope,\n\t\tsql: envelope.sql.map((entry) => {\n\t\t\tif (entry.subtype === 'replay-query') {\n\t\t\t\treturn {\n\t\t\t\t\t...entry,\n\t\t\t\t\tquery: entry.query.replace(fromURL, toURL),\n\t\t\t\t};\n\t\t\t} else if (entry.subtype === 'reconstruct-insert') {\n\t\t\t\tconst row = { ...entry.row };\n\t\t\t\tfor (const key in row) {\n\t\t\t\t\tif (typeof row[key] === 'string') {\n\t\t\t\t\t\trow[key] = (row[key] as string).replace(\n\t\t\t\t\t\t\turlRegexp,\n\t\t\t\t\t\t\turlReplacement\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t...entry,\n\t\t\t\t\trow,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn entry;\n\t\t}),\n\t});\n}\n\nfunction escapeRegex(string: string) {\n\treturn string.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n","import { SyncMiddleware } from '.';\nimport { SQLJournalEntry } from '../sql';\n\nexport const pruneSQLQueriesMiddleware = (): SyncMiddleware => ({\n\tbeforeSend: (envelope) => ({\n\t\t...envelope,\n\t\tsql: envelope.sql.filter(shouldSyncQuery),\n\t}),\n\tafterReceive: (envelope) => envelope,\n});\n\n/**\n * Determines whether a SQL query should be considered private\n * to the current site. Private queries are not synced with other\n * sites. For example:\n *\n * * SELECT queries\n * * Transients\n * * Session tokens\n *\n * ...and more.\n *\n * @param entry - The SQL Journal entry.\n * @returns Whether the query should be considered private.\n */\nconst shouldSyncQuery = (entry: SQLJournalEntry) => {\n\tif (entry.query_type === 'SELECT') {\n\t\treturn false;\n\t}\n\tconst queryType = entry.query_type;\n\tconst tableName = entry.table_name?.toLowerCase();\n\n\tif (entry.subtype === 'replay-query') {\n\t\tconst query = entry.query.trim();\n\t\t// Don't sync cron updates\n\t\tif (\n\t\t\tqueryType === 'UPDATE' &&\n\t\t\ttableName === 'wp_options' &&\n\t\t\tquery.endsWith(\"`option_name` = 'cron'\")\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (entry.subtype === 'reconstruct-insert') {\n\t\t// Don't sync transients\n\t\tif (tableName === 'wp_options') {\n\t\t\tconst optionName = entry.row.option_name + '';\n\t\t\tif (\n\t\t\t\toptionName.startsWith('_transient_') ||\n\t\t\t\toptionName.startsWith('_site_transient_')\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// Don't sync session tokens\n\t\tif (tableName === 'wp_usermeta') {\n\t\t\tif (entry.row.meta_key === 'session_tokens') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n};\n","import {\n\thydrateUpdateFileOps,\n\tnormalizeFilesystemOperations,\n} from '@php-wasm/fs-journal';\nimport { SyncMiddleware } from '.';\nimport { UniversalPHP } from '@php-wasm/universal';\n\nexport const hydrateFsWritesMiddleware = (\n\tphp: UniversalPHP\n): SyncMiddleware => ({\n\tbeforeSend: async (envelope) => ({\n\t\t...envelope,\n\t\tfs: await hydrateUpdateFileOps(\n\t\t\tphp,\n\t\t\tnormalizeFilesystemOperations(envelope.fs)\n\t\t),\n\t}),\n\tafterReceive: (envelopes) => envelopes,\n});\n","import { PlaygroundClient } from '@wp-playground/remote';\nimport { installSqlSyncMuPlugin, overrideAutoincrementSequences } from './sql';\nimport { journalFSOperations } from './fs';\nimport { SQLJournalEntry, journalSQLQueries, replaySQLJournal } from './sql';\nimport { PlaygroundSyncTransport, TransportEnvelope } from './transports';\nimport { FilesystemOperation } from '@php-wasm/fs-journal';\nimport { SyncMiddleware, marshallSiteURLMiddleware } from './middleware';\nimport { pruneSQLQueriesMiddleware } from './middleware/prune-sql-queries';\nimport { hydrateFsWritesMiddleware } from './middleware/hydrate-fs-writes';\n\nexport interface SyncOptions {\n\tautoincrementOffset: number;\n\ttransport: PlaygroundSyncTransport;\n\tmiddlewares?: SyncMiddleware[];\n}\n\nexport async function setupPlaygroundSync(\n\tplayground: PlaygroundClient,\n\t{ autoincrementOffset, transport, middlewares = [] }: SyncOptions\n) {\n\tmiddlewares = [\n\t\tpruneSQLQueriesMiddleware(),\n\t\tmarshallSiteURLMiddleware(await playground.absoluteUrl),\n\t\thydrateFsWritesMiddleware(playground),\n\t\t...middlewares,\n\t];\n\n\tawait installSqlSyncMuPlugin(playground);\n\tawait overrideAutoincrementSequences(playground, autoincrementOffset);\n\n\ttransport.onChangesReceived(async (changes) => {\n\t\tfor (const middleware of middlewares) {\n\t\t\tchanges = await middleware.afterReceive(changes);\n\t\t}\n\t\tawait playground.replayFSJournal(changes.fs);\n\t\tawait replaySQLJournal(playground, changes.sql);\n\t});\n\n\tlet localChanges: TransportEnvelope = { fs: [], sql: [] };\n\tjournalSQLQueries(playground, (query: SQLJournalEntry) => {\n\t\tlocalChanges.sql.push(query);\n\t});\n\tjournalFSOperations(playground, (op: FilesystemOperation) => {\n\t\tlocalChanges.fs.push(op);\n\t});\n\n\t// Flush the journal at most every 3 seconds\n\tconst flushJournal = async () => {\n\t\tlet flushedChanges = localChanges;\n\t\tlocalChanges = { fs: [], sql: [] };\n\t\tfor (const middleware of middlewares) {\n\t\t\tflushedChanges = await middleware.beforeSend(flushedChanges);\n\t\t}\n\t\tif (!flushedChanges.sql.length && !flushedChanges.fs.length) {\n\t\t\treturn;\n\t\t}\n\t\ttransport.sendChanges(flushedChanges);\n\t};\n\n\tconst loopAfterInterval = async (f: Function, ms: number) => {\n\t\tawait f();\n\t\tsetTimeout(loopAfterInterval, ms, f, ms);\n\t};\n\n\tloopAfterInterval(flushJournal, 3000);\n}\n"],"names":["normalizeFilesystemOperations","journal","substitutions","i","j","formerType","checkRelationship","latter","former","logger","joinPaths","updated","op","index","latterPath","latterIsDir","formerIsDir","formerPath","hydrateUpdateFileOps","php","entries","updates","hydrateOp","hydrateLock","Semaphore","release","e","logSqlQueries","installSqlSyncMuPlugin","playground","overrideAutoincrementSequences","baseOffset","knownIds","initializationResult","phpVar","assertEmptyOutput","journalSQLQueries","onCommit","activeTransaction","messageString","message","command","entry","replaySQLJournal","js","phpVars","result","errorMessage","journalFSOperations","onEntry","ParentWindowTransport","envelope","fn","event","NoopTransport","callback","changes","loggerMiddleware","clientId","marshallSiteURLMiddleware","localSiteUrl","placeholderUrl","siteURLMapper","fromURL","toURL","urlRegexp","escapeRegex","urlReplacement","row","key","string","pruneSQLQueriesMiddleware","shouldSyncQuery","queryType","tableName","query","optionName","hydrateFsWritesMiddleware","envelopes","setupPlaygroundSync","autoincrementOffset","transport","middlewares","middleware","localChanges","flushJournal","flushedChanges","loopAfterInterval","f","ms"],"mappings":"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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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"}